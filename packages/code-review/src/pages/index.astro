---
---

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Code Review Tool</title>
		<script type="module">
			import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
			window.mermaid = mermaid;
		</script>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				background: #1e1e1e;
				color: #d4d4d4;
				height: 100vh;
				overflow: hidden;
			}

			.container {
				display: flex;
				flex-direction: column;
				height: 100vh;
			}

			.header {
				background: #2d2d30;
				padding: 1rem 2rem;
				border-bottom: 1px solid #3e3e42;
			}

			.header h1 {
				font-size: 1.5rem;
				font-weight: 600;
				color: #ffffff;
			}

			.content {
				display: flex;
				flex: 1;
				overflow: hidden;
			}

			.pane {
				flex: 1;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			.pane-header {
				background: #2d2d30;
				padding: 0.75rem 1rem;
				border-bottom: 1px solid #3e3e42;
				font-weight: 600;
				font-size: 0.9rem;
			}

			.pane-content {
				flex: 1;
				overflow: auto;
				padding: 1rem;
			}

			.diagram-pane {
				border-right: 1px solid #3e3e42;
			}

			.diff-pane {
				background: #1e1e1e;
				border-right: 1px solid #3e3e42;
			}

			.call-hierarchy-pane {
				flex: 0 0 400px;
				background: #1e1e1e;
			}

			.call-hierarchy-content {
				font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
				font-size: 0.875rem;
			}

			.target-symbol {
				padding: 1rem;
				border-bottom: 1px solid #3e3e42;
				background: #2d2d30;
			}

			.target-symbol h3 {
				color: #4ec9b0;
				font-size: 1rem;
				margin-bottom: 0.5rem;
			}

			.target-symbol code {
				color: #d4d4d4;
				font-size: 0.8rem;
			}

			.hierarchy-section {
				margin: 1rem 0;
			}

			.hierarchy-section-header {
				padding: 0.75rem 1rem;
				background: #2d2d30;
				border: none;
				color: #d4d4d4;
				font-size: 0.9rem;
				font-weight: 600;
				cursor: pointer;
				width: 100%;
				text-align: left;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.hierarchy-section-header:hover {
				background: #3e3e42;
			}

			.call-tree {
				list-style: none;
				padding: 0;
				margin: 0;
			}

			.call-site {
				border-bottom: 1px solid #3e3e42;
			}

			.call-link {
				display: block;
				padding: 0.75rem 1rem;
				background: none;
				border: none;
				color: #d4d4d4;
				text-align: left;
				cursor: pointer;
				width: 100%;
				transition: background 0.2s;
			}

			.call-link:hover {
				background: #2d2d30;
			}

			.symbol-name {
				color: #4ec9b0;
				font-weight: 600;
				display: block;
				margin-bottom: 0.25rem;
			}

			.location {
				color: #858585;
				font-size: 0.8rem;
			}

			.context-code {
				background: #1a1a1a;
				padding: 0.5rem 1rem;
				margin: 0.5rem 1rem;
				border-left: 3px solid #0e639c;
				font-size: 0.8rem;
				color: #cccccc;
				white-space: pre-wrap;
				overflow-x: auto;
			}

			.call-type-badge {
				display: inline-block;
				padding: 0.2rem 0.5rem;
				background: #0e639c;
				color: white;
				border-radius: 3px;
				font-size: 0.7rem;
				margin-left: 0.5rem;
			}

			.empty-state {
				padding: 2rem;
				text-align: center;
				color: #858585;
			}

			.selected-text {
				background: #264f78 !important;
			}

			#mermaid-diagram {
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.diff-content {
				font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
				font-size: 0.875rem;
				line-height: 1.5;
				white-space: pre-wrap;
			}

			.diff-file {
				margin-bottom: 2rem;
			}

			.diff-file-header {
				background: #2d2d30;
				padding: 0.5rem 1rem;
				border-radius: 4px 4px 0 0;
				font-weight: 600;
				border: 1px solid #3e3e42;
				border-bottom: none;
			}

			.diff-lines {
				border: 1px solid #3e3e42;
				border-radius: 0 0 4px 4px;
				overflow: hidden;
			}

			.diff-line {
				padding: 2px 1rem;
				display: flex;
			}

			.line-number {
				min-width: 50px;
				text-align: right;
				padding-right: 1rem;
				color: #858585;
				user-select: none;
			}

			.line-content {
				flex: 1;
			}

			.diff-line.addition {
				background: #1e3c1e;
			}

			.diff-line.deletion {
				background: #4b1818;
			}

			.diff-line.context {
				background: #1e1e1e;
			}

			.addition .line-content {
				color: #4ec9b0;
			}

			.deletion .line-content {
				color: #f48771;
			}

			.node-highlight {
				background: #264f78 !important;
				box-shadow: 0 0 0 2px #0e639c;
			}

			.controls {
				background: #2d2d30;
				padding: 1rem;
				border-bottom: 1px solid #3e3e42;
			}

			.file-input-wrapper {
				display: flex;
				gap: 1rem;
				align-items: center;
			}

			input[type="file"] {
				display: none;
			}

			.file-label {
				background: #0e639c;
				color: white;
				padding: 0.5rem 1rem;
				border-radius: 4px;
				cursor: pointer;
				font-size: 0.875rem;
				transition: background 0.2s;
			}

			.file-label:hover {
				background: #1177bb;
			}

			.file-name {
				color: #cccccc;
				font-size: 0.875rem;
			}

			.loading {
				color: #cccccc;
				text-align: center;
				padding: 2rem;
			}

			.error {
				color: #f48771;
				padding: 1rem;
				background: #4b1818;
				border-radius: 4px;
				margin: 1rem;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="header">
				<h1>Code Review Tool</h1>
			</div>

			<div class="controls">
				<div class="file-input-wrapper">
					<label for="diff-file" class="file-label">
						Load Git Diff
					</label>
					<input type="file" id="diff-file" accept=".diff,.patch,.txt" />
					<span class="file-name" id="file-name">No file selected</span>
				</div>
			</div>

			<div class="content">
				<div class="pane diagram-pane">
					<div class="pane-header">Dataflow Diagram</div>
					<div class="pane-content">
						<div id="mermaid-diagram">
							<div class="loading">Load a git diff file to see the dataflow diagram</div>
						</div>
					</div>
				</div>

				<div class="pane diff-pane">
					<div class="pane-header">Diff Details</div>
					<div class="pane-content">
						<div id="diff-content" class="diff-content">
							<div class="loading">Select a node in the diagram to see the relevant diff</div>
						</div>
					</div>
				</div>

				<div class="pane call-hierarchy-pane">
					<div class="pane-header">Call Hierarchy</div>
					<div class="pane-content" style="padding: 0;">
						<div id="call-hierarchy-content" class="call-hierarchy-content">
							<div class="empty-state">Select code in the diff to view call hierarchy</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<script type="module">
			const mermaid = window.mermaid;

			mermaid.initialize({
				startOnLoad: false,
				theme: 'dark',
				themeVariables: {
					darkMode: true,
					background: '#1e1e1e',
					primaryColor: '#0e639c',
					primaryTextColor: '#d4d4d4',
					primaryBorderColor: '#3e3e42',
					lineColor: '#858585',
					secondaryColor: '#2d2d30',
					tertiaryColor: '#1e1e1e',
				}
			});

			let parsedDiff = null;
			let currentDiagram = null;
			let selectedCode = null;
			let currentFile = null;

			// File input handling
			const fileInput = document.getElementById('diff-file');
			const fileName = document.getElementById('file-name');
			const mermaidContainer = document.getElementById('mermaid-diagram');
			const diffContainer = document.getElementById('diff-content');
			const callHierarchyContainer = document.getElementById('call-hierarchy-content');

			fileInput.addEventListener('change', async (e) => {
				const file = e.target.files[0];
				if (!file) return;

				fileName.textContent = file.name;
				mermaidContainer.innerHTML = '<div class="loading">Analyzing diff...</div>';

				try {
					const content = await file.text();
					parsedDiff = parseDiff(content);
					currentDiagram = generateMermaidDiagram(parsedDiff);
					await renderDiagram(currentDiagram);
					setupInteractivity();
				} catch (error) {
					mermaidContainer.innerHTML = `<div class="error">Error: ${error.message}</div>`;
					console.error('Error processing diff:', error);
				}
			});

			// Parse git diff
			function parseDiff(diffText) {
				const files = [];
				const lines = diffText.split('\n');
				let currentFile = null;
				let currentHunk = null;

				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];

					// New file
					if (line.startsWith('diff --git')) {
						if (currentFile) {
							files.push(currentFile);
						}
						const match = line.match(/diff --git a\/(.+?) b\/(.+)/);
						currentFile = {
							oldPath: match?.[1] || '',
							newPath: match?.[2] || '',
							hunks: [],
							additions: 0,
							deletions: 0,
						};
						currentHunk = null;
					}
					// File paths
					else if (line.startsWith('---')) {
						if (currentFile) {
							currentFile.oldPath = line.substring(4).replace(/^a\//, '');
						}
					}
					else if (line.startsWith('+++')) {
						if (currentFile) {
							currentFile.newPath = line.substring(4).replace(/^b\//, '');
						}
					}
					// Hunk header
					else if (line.startsWith('@@')) {
						const match = line.match(/@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@(.*)/);
						currentHunk = {
							oldStart: parseInt(match?.[1] || '0'),
							oldLines: parseInt(match?.[2] || '1'),
							newStart: parseInt(match?.[3] || '0'),
							newLines: parseInt(match?.[4] || '1'),
							header: match?.[5]?.trim() || '',
							lines: [],
						};
						if (currentFile) {
							currentFile.hunks.push(currentHunk);
						}
					}
					// Hunk content
					else if (currentHunk && (line.startsWith('+') || line.startsWith('-') || line.startsWith(' '))) {
						const type = line[0] === '+' ? 'addition' : line[0] === '-' ? 'deletion' : 'context';
						currentHunk.lines.push({
							type,
							content: line.substring(1),
						});
						if (type === 'addition' && currentFile) currentFile.additions++;
						if (type === 'deletion' && currentFile) currentFile.deletions++;
					}
				}

				if (currentFile) {
					files.push(currentFile);
				}

				return { files };
			}

			// Generate Mermaid diagram from diff
			function generateMermaidDiagram(diff) {
				if (!diff || !diff.files || diff.files.length === 0) {
					return 'graph TD\n    A[No changes detected]';
				}

				let diagram = 'graph TD\n';
				const nodes = new Map();
				let nodeId = 0;

				diff.files.forEach((file, fileIndex) => {
					const fileName = file.newPath || file.oldPath;
					const shortName = fileName.split('/').pop();
					const id = `file${nodeId++}`;

					nodes.set(fileName, { id, file, fileIndex });

					const changeType = file.additions > 0 && file.deletions > 0 ? 'modified' :
									   file.additions > 0 ? 'added' : 'deleted';
					const symbol = changeType === 'modified' ? '±' :
								   changeType === 'added' ? '+' : '-';

					diagram += `    ${id}["${shortName}<br/>${symbol}${file.additions + file.deletions} lines"]\n`;
					diagram += `    style ${id} fill:#0e639c,stroke:#1177bb,color:#fff\n`;
				});

				// Try to infer relationships based on imports or function calls
				diff.files.forEach((file, fileIndex) => {
					const fileName = file.newPath || file.oldPath;
					const currentNode = nodes.get(fileName);

					// Look for imports or dependencies in the diff
					file.hunks.forEach(hunk => {
						hunk.lines.forEach(line => {
							if (line.type === 'addition' &&
								(line.content.includes('import') ||
								 line.content.includes('require') ||
								 line.content.includes('from '))) {

								// Try to match with other files in the diff
								nodes.forEach((targetNode, targetFile) => {
									if (targetFile !== fileName) {
										const targetShort = targetFile.split('/').pop().replace(/\.(js|ts|py|java|go)$/, '');
										if (line.content.includes(targetShort)) {
											diagram += `    ${currentNode.id} --> ${targetNode.id}\n`;
										}
									}
								});
							}
						});
					});
				});

				return diagram;
			}

			// Render Mermaid diagram
			async function renderDiagram(diagramCode) {
				mermaidContainer.innerHTML = '';
				const { svg } = await mermaid.render('diagram', diagramCode);
				mermaidContainer.innerHTML = svg;
			}

			// Setup interactivity
			function setupInteractivity() {
				const nodes = mermaidContainer.querySelectorAll('.node');

				nodes.forEach((node, index) => {
					node.style.cursor = 'pointer';
					node.addEventListener('click', () => {
						// Remove previous highlights
						nodes.forEach(n => n.classList.remove('node-highlight'));

						// Highlight clicked node
						node.classList.add('node-highlight');

						// Show corresponding diff
						if (parsedDiff && parsedDiff.files[index]) {
							currentFile = parsedDiff.files[index];
							displayDiff(currentFile);
						}
					});
				});
			}

			// Display diff for selected file
			function displayDiff(file) {
				let html = `<div class="diff-file">`;
				html += `<div class="diff-file-header">${file.newPath || file.oldPath}</div>`;
				html += `<div class="diff-lines">`;

				file.hunks.forEach(hunk => {
					let oldLine = hunk.oldStart;
					let newLine = hunk.newStart;

					hunk.lines.forEach(line => {
						const lineClass = line.type;
						let lineNum = '';

						if (line.type === 'deletion') {
							lineNum = oldLine++;
						} else if (line.type === 'addition') {
							lineNum = newLine++;
						} else {
							lineNum = newLine++;
							oldLine++;
						}

						html += `<div class="diff-line ${lineClass}">`;
						html += `<span class="line-number">${lineNum}</span>`;
						html += `<span class="line-content">${escapeHtml(line.content)}</span>`;
						html += `</div>`;
					});
				});

				html += `</div></div>`;
				diffContainer.innerHTML = html;
			}

			// Escape HTML
			function escapeHtml(text) {
				const div = document.createElement('div');
				div.textContent = text;
				return div.innerHTML;
			}

			// Setup text selection handler for call hierarchy
			function setupTextSelection() {
				document.addEventListener('mouseup', () => {
					const selection = window.getSelection();
					const selectedText = selection.toString().trim();

					if (selectedText && currentFile) {
						// Get the selected element to determine context
						const range = selection.getRangeAt(0);
						const container = range.commonAncestorContainer;
						const lineElement = container.parentElement?.closest('.diff-line');

						if (lineElement) {
							selectedCode = {
								text: selectedText,
								file: currentFile,
								element: lineElement
							};

							// Extract and display call hierarchy
							const hierarchy = extractCallHierarchy(selectedText, currentFile);
							renderCallHierarchy(hierarchy);
						}
					}
				});
			}

			// Extract call hierarchy from selected code
			function extractCallHierarchy(selectedText, file) {
				// Simple heuristic-based function extraction
				const functionPatterns = [
					/function\s+(\w+)/,          // JavaScript function
					/const\s+(\w+)\s*=/,         // JavaScript const/arrow function
					/def\s+(\w+)/,               // Python function
					/func\s+(\w+)/,              // Go function
					/(\w+)\s*\(/,                // General function call
				];

				let functionName = null;
				for (const pattern of functionPatterns) {
					const match = selectedText.match(pattern);
					if (match) {
						functionName = match[1] || match[0].replace(/\s*\(.*/, '');
						break;
					}
				}

				if (!functionName) {
					return null;
				}

				// Search for calls to this function (incoming) and calls from this function (outgoing)
				const incomingCalls = [];
				const outgoingCalls = [];

				// Search all files in the diff
				parsedDiff.files.forEach(searchFile => {
					searchFile.hunks.forEach(hunk => {
						hunk.lines.forEach((line, lineIdx) => {
							const content = line.content;

							// Check for calls to our function (incoming)
							const callPattern = new RegExp(`\\b${functionName}\\s*\\(`, 'g');
							if (callPattern.test(content) && !content.includes(`function ${functionName}`) && !content.includes(`def ${functionName}`)) {
								incomingCalls.push({
									file: searchFile.newPath || searchFile.oldPath,
									line: lineIdx + hunk.newStart,
									content: content.trim(),
									type: line.type
								});
							}

							// If this is our function, look for outgoing calls
							if (searchFile === file) {
								// Extract function calls from the content
								const outgoingPattern = /(\w+)\s*\(/g;
								let match;
								while ((match = outgoingPattern.exec(content)) !== null) {
									const calledFunction = match[1];
									// Exclude common keywords and our own function
									if (calledFunction !== functionName &&
										!['if', 'for', 'while', 'return', 'function', 'const', 'let', 'var'].includes(calledFunction)) {
										outgoingCalls.push({
											file: searchFile.newPath || searchFile.oldPath,
											line: lineIdx + hunk.newStart,
											content: content.trim(),
											functionName: calledFunction,
											type: line.type
										});
									}
								}
							}
						});
					});
				});

				return {
					targetFunction: functionName,
					signature: selectedText.split('\n')[0].trim(),
					incomingCalls: incomingCalls.slice(0, 10), // Limit to 10
					outgoingCalls: [...new Map(outgoingCalls.map(c => [c.functionName, c])).values()].slice(0, 10)
				};
			}

			// Render call hierarchy in the panel
			function renderCallHierarchy(hierarchy) {
				if (!hierarchy) {
					callHierarchyContainer.innerHTML = '<div class="empty-state">No function detected in selection</div>';
					return;
				}

				let html = '<div class="target-symbol">';
				html += `<h3>${escapeHtml(hierarchy.targetFunction)}</h3>`;
				html += `<code>${escapeHtml(hierarchy.signature)}</code>`;
				html += '</div>';

				// Incoming calls section
				html += '<div class="hierarchy-section">';
				html += `<button class="hierarchy-section-header" onclick="toggleSection('incoming')">`;
				html += `<span>▼</span> Incoming Calls (${hierarchy.incomingCalls.length})`;
				html += '</button>';
				html += '<div id="incoming-section" class="call-tree">';

				if (hierarchy.incomingCalls.length === 0) {
					html += '<div class="empty-state" style="padding: 1rem;">No incoming calls found</div>';
				} else {
					hierarchy.incomingCalls.forEach(call => {
						html += '<div class="call-site">';
						html += '<div class="call-link">';
						html += `<span class="symbol-name">${escapeHtml(call.file)}</span>`;
						html += `<span class="location">Line ${call.line}</span>`;
						html += `<span class="call-type-badge">${call.type}</span>`;
						html += '</div>';
						html += `<pre class="context-code">${escapeHtml(call.content)}</pre>`;
						html += '</div>';
					});
				}

				html += '</div></div>';

				// Outgoing calls section
				html += '<div class="hierarchy-section">';
				html += `<button class="hierarchy-section-header" onclick="toggleSection('outgoing')">`;
				html += `<span>▼</span> Outgoing Calls (${hierarchy.outgoingCalls.length})`;
				html += '</button>';
				html += '<div id="outgoing-section" class="call-tree">';

				if (hierarchy.outgoingCalls.length === 0) {
					html += '<div class="empty-state" style="padding: 1rem;">No outgoing calls found</div>';
				} else {
					hierarchy.outgoingCalls.forEach(call => {
						html += '<div class="call-site">';
						html += '<div class="call-link">';
						html += `<span class="symbol-name">${escapeHtml(call.functionName)}</span>`;
						html += `<span class="location">${escapeHtml(call.file)}:${call.line}</span>`;
						html += '</div>';
						html += `<pre class="context-code">${escapeHtml(call.content)}</pre>`;
						html += '</div>';
					});
				}

				html += '</div></div>';

				callHierarchyContainer.innerHTML = html;
			}

			// Toggle section visibility
			window.toggleSection = function(sectionId) {
				const section = document.getElementById(`${sectionId}-section`);
				if (section) {
					section.style.display = section.style.display === 'none' ? 'block' : 'none';
				}
			};

			// Initialize text selection handler
			setupTextSelection();
		</script>
	</body>
</html>
