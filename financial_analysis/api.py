"""Public API interfaces and orchestration for the ``financial_analysis`` package.

This module provides the implemented categorization flow
(:func:`categorize_expenses`) that prepares Canonical Transaction View (CTV)
records, calls the OpenAI Responses API, and returns aligned results. Other
interfaces remain stubs and raise ``NotImplementedError`` by design.
"""

from __future__ import annotations

import json
from collections.abc import Iterable, Mapping
from typing import Any, cast

from openai import OpenAI
from openai.types.responses import ResponseTextConfigParam

# Internal helpers (implementation modules)
from . import prompting
from .categorization import (
    ALLOWED_CATEGORIES,
    ensure_valid_ctv_descriptions,
    parse_and_align_categories,
)
from .models import (
    CategorizedTransaction,
    PartitionPeriod,
    RefundMatch,
    TransactionPartitions,
    Transactions,
)


def categorize_expenses(transactions: Transactions) -> Iterable[CategorizedTransaction]:
    """Categorize expenses via OpenAI Responses API (model: ``gpt-5``).

    Behavior:
    - Accepts an iterable of Canonical Transaction View (CTV) mapping objects.
    - Validates that each item has a non-empty ``description`` after trimming.
    - Builds a fresh CTV list with ``idx`` assigned 0..N-1 in input order
      (without mutating caller-provided objects).
    - Constructs prompts and a strict JSON schema; calls the OpenAI Responses
      API requesting JSON output for the allowed category set.
    - Parses and validates the model response, enforcing the category
      whitelist and alignment by ``idx``.
    - Returns an iterable of :class:`CategorizedTransaction` in the exact input
      order, where ``transaction`` is the original mapping object, unmodified.
    """

    # Coerce input to a concrete sequence to preserve order and allow indexing.
    original_seq_any = list(transactions)
    if not all(isinstance(item, Mapping) for item in original_seq_any):
        raise TypeError(
            "categorize_expenses expects each transaction to be a mapping (CTV) with keys "
            "like 'id', 'description', 'amount', 'date', 'merchant', 'memo'."
        )
    original_seq: list[Mapping[str, Any]] = list(original_seq_any)  # precise type

    # Build the CTV objects for the prompt, assigning idx 0..N-1.
    ctv_for_prompt: list[dict[str, Any]] = []
    for idx, record in enumerate(original_seq):
        # Use ``get`` to tolerate absent keys; values propagate as None.
        ctv_for_prompt.append(
            {
                "idx": idx,
                "id": record.get("id"),
                "description": record.get("description"),
                "amount": record.get("amount"),
                "date": record.get("date"),
                "merchant": record.get("merchant"),
                "memo": record.get("memo"),
            }
        )

    # Input validation (pre-request).
    ensure_valid_ctv_descriptions(ctv_for_prompt)

    # Prompts and strict JSON response format.
    system_instructions = prompting.build_system_instructions()
    ctv_json = prompting.serialize_ctv_to_json(ctv_for_prompt)
    user_content = prompting.build_user_content(ctv_json, allowed_categories=ALLOWED_CATEGORIES)
    response_format = prompting.build_response_format(ALLOWED_CATEGORIES)

    # Execute the Responses API call via the official OpenAI SDK.
    client = OpenAI()
    text_cfg: ResponseTextConfigParam = cast(ResponseTextConfigParam, {"format": response_format})
    resp = client.responses.create(
        model="gpt-5",
        instructions=system_instructions,
        input=user_content,
        text=text_cfg,
    )

    # Extract the model JSON from the Responses envelope and decode to Python.
    # Prefer the SDK's convenience property; fall back to inspecting the first
    # message/output item if necessary.
    text: str | None = getattr(resp, "output_text", None)
    if not text:
        try:
            # `resp.output` is a list of items; when present, the first item is
            # typically a message with `content[0].text` holding the string.
            first = resp.output[0] if getattr(resp, "output", None) else None
            content = getattr(first, "content", None)
            if content and len(content) > 0:
                maybe_text = getattr(content[0], "text", None)
                if isinstance(maybe_text, str):
                    text = maybe_text
        except Exception:  # noqa: BLE001 - defensive; shape differences are tolerated
            text = None
    if not text or not isinstance(text, str):
        raise ValueError("Unexpected Responses API shape; unable to locate text output")

    try:
        decoded: Mapping[str, Any] = json.loads(text)
    except json.JSONDecodeError as e:  # pragma: no cover - minimal defensive path
        raise ValueError("Model output was not valid JSON per the requested schema") from e

    # Parse/validate and align by idx back to the original objects.
    categories_by_idx = parse_and_align_categories(decoded, num_items=len(original_seq))
    results: list[CategorizedTransaction] = [
        CategorizedTransaction(transaction=original_seq[i], category=categories_by_idx[i])
        for i in range(len(original_seq))
    ]
    return results


def identify_refunds(transactions: Transactions) -> Iterable[RefundMatch]:
    """Identify expense/refund pairs by inverse amounts (interface only).

    Input
    -----
    transactions:
        A collection of :data:`~financial_analysis.models.TransactionRecord`
        items to search for refund relationships.

    Output
    ------
    An iterable of expense/refund pairs as
    :class:`~financial_analysis.models.RefundMatch`, where each element holds
    the full :data:`TransactionRecord` for the expense and its matching
    refund.

    Notes
    -----
    - The amount column name and format are unspecified (e.g., whether refunds
      are negative amounts, sign conventions, currency/rounding).
    - Date schema and any time-based disambiguation rules are not defined.
    """

    raise NotImplementedError


def partition_transactions(
    transactions: Transactions, partition_period: PartitionPeriod
) -> TransactionPartitions:
    """Partition a transaction collection into period-based subsets (interface only).

    Input
    -----
    transactions:
        A collection of transaction records.
    partition_period:
        A structured period spec (see
        :class:`~financial_analysis.models.PartitionPeriod`) that supports any
        combination of ``years``, ``months``, ``weeks``, and ``days``. Each
        field is optional and the fields are not mutually exclusive.

    Output
    ------
    An iterable of partitions, where each partition is a subset of the input
    transactions (see :data:`~financial_analysis.models.TransactionPartitions`).

    Notes
    -----
    - The required date column name and its format are not specified and must
      be clarified for any implementation.
    - The ordering of transactions within and across partitions is unspecified.
    """

    raise NotImplementedError


def report_trends(transactions: Transactions) -> str:
    """Produce a pretty-printed trends table by category by month (interface only).

    Input
    -----
    transactions:
        A collection of transaction records.

    Output
    ------
    A string containing a pretty-printed table showing spending totals by
    category by month and overall totals. Rendering/printing of this string is
    the caller's responsibility; this API returns the string only.

    Notes
    -----
    - Required column names and formats (e.g., date, amount, category) are not
      specified and require clarification.
    - Timezone/calendar assumptions and how months are defined (posting vs
      transaction date) are unspecified.
    - Category normalization rules and aggregation semantics are not defined.
    """

    raise NotImplementedError


def review_transaction_categories(
    transactions_with_categories: Iterable[CategorizedTransaction],
) -> Iterable[CategorizedTransaction]:
    """Review and correct transaction categories via a REPL-style flow (interface only).

    Input
    -----
    transactions_with_categories:
        An iterable of transactions that already have categories assigned.

    Output
    ------
    An iterable of transactions with verified or corrected categories following
    a REPL-style review process (see
    :class:`~financial_analysis.models.CategorizedTransaction`).

    Notes
    -----
    - REPL interaction details (prompts, commands, confirmation flow) are not
      specified and require clarification.
    - The category ontology and normalization rules are not defined.
    - CSV schema (required column names and formats) remains unspecified.
    """

    raise NotImplementedError
