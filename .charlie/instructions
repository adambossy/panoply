# Charlie Instructions: Style Guide

Purpose
- A concise, practical style guide for this repository. It governs how we name things, structure code for readability, and express common boilerplate. It also captures a few project constraints (CLI, env loading). Keep changes minimal and focused; prefer small, intentional diffs.

Project conventions and constraints
- CLI
  - New CLI entry points and any CLI refactors must use Typer. Expose commands via a Typer app; do not hand-roll argparse or custom parsers.
- Environment loading
  - Load environment variables from a `.env` file using `python-dotenv`. Call `load_dotenv(override=False)` once in the CLI entrypoint before command execution; do not override variables that are already set.
- Scale assumptions
  - This app targets a single-user workflow. Do not assume external clients, observability stacks, or production-grade frills by default.
- General code quality
  - Prefer small functions with descriptive names; split large nested logic into helpers or modules instead of defining nested functions.
  - Keep imports at module top level; avoid importing modules inside functions.
  - Do not use banner comments.

Core style principles
- Readability and predictability
  - Favor straightforward, explicit code over clever tricks.
  - Use a single, well-defined core path for public APIs (one way in, one way out).
  - Choose names that reflect intent (what or who), not implementation.
- Local reasoning and encapsulation
  - Each function/class has one clear responsibility.
  - Encapsulate invariants (validation, canonical forms) so callers can assume them.
  - Minimize coupling, maximize cohesion.
- Graceful extension (open–closed)
  - Provide hooks/adapters so behavior can be extended without changing internals.
  - Layer abstractions cleanly (e.g., transport, serialization, error handling).
  - Define a repository-specific root exception (e.g., `AppError`) in a shared `errors.py` and derive specific subtypes per domain.
  - Do not raise bare `Exception`. Wrap external exceptions and raise `AppError` subclasses so the public surface exposes a consistent error taxonomy.
  - When wrapping external exceptions, chain the original using `raise ... from e` to preserve the cause and traceback. For example, raise a domain-specific subclass of `AppError`:

    ```py
    try:
        do_the_thing()
    except ExternalError as e:
        raise DomainOperationError("Failed to do the thing") from e
    ```
- Maintainability and process hygiene
  - Pair features with tests and documentation.
  - Use the tools configured in `pyproject.toml` (e.g., Ruff for lint/format if present), mypy for type checking, pytest for tests, and pre-commit for hooks.
  - Refactor continuously; eliminate duplication and accidental complexity.
  - Prefer small, purposeful commits with clear messages.

Readability
- Keep top-level orchestration small; delegate to tiny, focused helpers. A public entrypoint should mostly compose helpers.
- Normalize inputs and precompute early when feasible; preserve original order. When performing rewrite/transformation workflows, keep a stable index (e.g., `pos`) to ensure determinism.
- Group with simple, explicit data structures. Prefer sets, dicts, and lists with clear loops over clever one-liners; introduce specialized structures only when they improve clarity.
- Prefer early returns and small loops over deep nesting. Short-circuit empties and error cases as soon as they are known.
- Inject I/O for testability. Accept `print_fn`, `input_fn`, or a selector callback; avoid capturing patched builtins at import time. Do not bind builtins as default parameter values—default to `None` and assign inside the function body. For example:

  ```py
  def prompt(*, input_fn=None, print_fn=None):
      if input_fn is None:
          input_fn = input
      if print_fn is None:
          print_fn = print
      # use input_fn / print_fn below
  ```
- Validate early with precise errors that include the actual type (e.g., `...; got {type_name}`) for injected callbacks and external inputs.
- Keep user-facing prints short and actionable. Use sentence case, minimal punctuation, and introduce lists with a colon.
- Document non-obvious formatting or ordering choices in a short inline comment near the code that depends on them.

Naming
- Name by role: nouns for data, verbs for actions. Examples: data `PreparedItem`; actions like `materialize_and_prepare`, `persist_group`, `render_group_context`.
- Use module-private helpers for internals and expose a minimal public API. Prefix internals with a single underscore and (optionally) export the public surface via `__all__`.
- Prefer keyword-only parameters for helpers with multiple arguments or boolean flags. Use `*,` after the primary subject to force clarity at call sites. Avoid boolean flags that change behavior; prefer an `Enum` or strategy object to represent modes.
- Use short, conventional abbreviations only when the context is obvious (e.g., `tx` for transaction, `eid` for external id, `fp` for fingerprint, `pos` for original index). Otherwise, spell names out.
- Avoid single-letter variable names in new code; choose intention-revealing names instead (e.g., `idx`, `row`, `item`, `count`). Narrow exceptions are allowed in short, self-contained scopes for domain-standard mathematical symbols and widely understood local conventions (e.g., `i`/`j` for algorithmic indices, `x`/`y` for coordinates, `k`/`v` in a one-liner dict comprehension, `n` for sample size). Prefer `idx`/`pos` over `i`/`j` in general-purpose loops.
- Adopt consistent, intention-revealing prefixes:
  - `group_*` for data scoped to the current duplicate group (e.g., `group_items`, `group_eids`).
  - `db_*` for values sourced from the database (e.g., `db_dupes`).
  - `allowed_categories` (a set) for allowed categories; `category_options` (a list) for UI-ready choices; `default_category` for the selected default.

Boilerplate patterns
- I/O and selector injection
  - Accept injectable `print_fn`, `input_fn`, and a selection function when interaction is needed (defaults noted in Readability). Strip and validate selector returns as strings.
- Validation
  - Guard injected types and external values explicitly; raise with the concrete type name in the message.
- Control flow
  - Prefer early returns for empty inputs, short-circuit unanimous cases, and immediate retries for user-driven flows.
- Data containers
  - Use efficient, intention-revealing containers. Prefer `@dataclass(frozen=True, slots=True)` for immutable prepared records (target Python version is defined in `pyproject.toml`, currently 3.12).
- Comments
  - Reserve comments for intent and non-obvious decisions. Avoid narrating the change itself.

When in doubt, choose the option that improves local readability for the next reader and keeps the public surface simple and predictable.
